import{_ as i,o as s,c as t,a5 as e}from"./chunks/framework.IJ9y2eDM.js";const k=JSON.parse('{"title":"Conventional Commits","description":"","frontmatter":{},"headers":[],"relativePath":"conventional-commits.md","filePath":"conventional-commits.md"}'),a={name:"conventional-commits.md"},n=e(`<h1 id="conventional-commits" tabindex="-1">Conventional Commits <a class="header-anchor" href="#conventional-commits" aria-label="Permalink to &quot;Conventional Commits&quot;">​</a></h1><p><strong>Conventional Commits</strong> is a simple convention for commit messages. It provides rules to maintain a clear and structured commit history.</p><h2 id="how-to-use-commit-message-convention" tabindex="-1">How to Use Commit Message Convention? <a class="header-anchor" href="#how-to-use-commit-message-convention" aria-label="Permalink to &quot;How to Use Commit Message Convention?&quot;">​</a></h2><p>The rules are straightforward. As shown below, we have the type, scope, and subject of the commit.</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">?scope</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">subject</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">body</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">footer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div><p>Восклицательный знак указывает на обязательные атрибуты, а вопросительный — на необязательные.</p><h3 id="subject-сообщение-коммита" tabindex="-1">subject: сообщение коммита <a class="header-anchor" href="#subject-сообщение-коммита" aria-label="Permalink to &quot;subject: сообщение коммита&quot;">​</a></h3><p>Мы сообщаем нашей команде, что сделает коммит, если его применить. В английском языке нужно использовать повелительное наклонение, а не прошедшее время.</p><p>Проверка правильности построения предложения — подставить в начало условие и вспомогательный глагол will.</p><p>Паттерн: «If applied, this commit will…».</p><p>Аналог на русском: «При применении этот коммит &lt;что сделает?&gt;».</p><p>Сообщение «If applied, this commit will change the markup» имеет гораздо больше смысла, чем «If applied, this commit will changed the markup».</p><h3 id="type-типы-коммитов" tabindex="-1">type: типы коммитов <a class="header-anchor" href="#type-типы-коммитов" aria-label="Permalink to &quot;type: типы коммитов&quot;">​</a></h3><p>Тип должен сообщить нам, какое изменение или итерация производится. Исходя из правил соглашения, мы имеем следующие типы:</p><ul><li><p><strong>test</strong>: указывает на любое создание или изменение кода тестов. Пример — создание модульных тестов.</p></li><li><p><strong>feat</strong>: указывает на разработку новой функции для проекта. Примеры: добавление сервиса, функциональности, конечной точки и т.д.</p></li><li><p><strong>refactor</strong>: используется, когда происходит рефакторинг кода, не влияющий на логику/правила системы. Пример — изменения после ревью кода.</p></li><li><p><strong>style</strong>: используется при изменениях форматирования и стиля кода, которые никак не меняют систему. Примеры: смена руководства по стилю или соглашения о линтинге, исправление отступов, удаление пробелов, удаление комментариев и т.д….</p></li><li><p><strong>fix</strong>: используется при исправлении ошибок, которые порождают баги в системе. Пример — применение обработки для функции, которая ведет себя не так, как ожидалось, и возвращает ошибку.</p></li><li><p><strong>chore</strong>: указывает на изменения в проекте, которые не влияют на систему или тестовые файлы. Это изменения, связанные с разработкой. Примеры: изменение правил для eslint, добавление prettier, добавление расширений файлов в .gitignore.</p></li><li><p><strong>docs</strong>: используется при изменениях в документации проекта. Пример: добавление сведений в документацию API, измение README и т.д.</p></li><li><p><strong>build</strong>: используется для указания изменений, которые влияют на процесс сборки проекта, или внешних зависимостей. Примеры: Gulp, добавление/удаление зависимостей npm и т.д..</p></li><li><p><strong>perf</strong>: указывает на изменение, которое улучшает производительность системы. Пример — замена ForEach на While.</p></li><li><p><strong>ci</strong>: используется для указания на изменения в конфигурационных файлах CI. Примеры: Circle, Travis, BrowserStack и т.д.</p></li><li><p><strong>revert</strong>: указывает на отмену предыдущего коммита.</p></li></ul><p>Примечания:</p><ul><li><p>Для каждого коммита указывается только один тип.</p></li><li><p>type — обязательный атрибут.</p></li><li><p>Если вы не знаете, какой тип использовать, вероятно, это большое изменение, и можно разделить этот коммит на два или на большее число коммитов.</p></li><li><p>Разница между build и chore может быть довольно тонкой, что может привести к путанице. Поэтому важно знать, какой тип когда использовать. В случае с Node.js, например, мы можем считать, что когда происходит добавление/изменение определенной зависимости разработки, присутствующей в devDependencies, мы используем chore. Для изменений/добавлений общих зависимостей проекта, которые оказывают прямое и реальное влияние на систему, мы используем build.</p></li></ul><h3 id="scope-контекст-коммита" tabindex="-1">scope: контекст коммита <a class="header-anchor" href="#scope-контекст-коммита" aria-label="Permalink to &quot;scope: контекст коммита&quot;">​</a></h3><p>Прочитав тип коммита и его сообщение, разработчик уже легко поймет, какое изменение было внесено и что принесет этот коммит, если его применить.</p><p>Несмотря на то, что атрибут scope не является обязательным, его можно использовать для добавления контекста. Это позволит сделать сообщение коммита максимально кратким и лаконичным. Помните, что область действия нужно указывать в скобках. Разделяются скоупы символом /.</p><div style="display:none;" data-pagefind-meta="base64:JTdCJTdE"></div>`,21),o=[n];function l(p,r,h,c,d,m){return s(),t("div",null,o)}const u=i(a,[["render",l]]);export{k as __pageData,u as default};
